/*
 * Copyright (C) 2018 Square, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.tschuchort.compiletesting

import org.jetbrains.kotlin.cli.common.arguments.K2JVMCompilerArguments
import java.io.*
import java.net.URLClassLoader

data class PluginOption(val pluginId: PluginId, val optionName: OptionName, val optionValue: OptionValue)

typealias PluginId = String
typealias OptionName = String
typealias OptionValue = String

@Suppress("MemberVisibilityCanBePrivate")
class KotlinCompilation internal constructor(
	override val model: CompilationModelImpl.JvmCompilationModelImpl
) : AbstractKotlinCompilation<K2JVMCompilerArguments>(model), JvmCompilationModel by model {
	constructor() : this(CompilationModelImpl.JvmCompilationModelImpl())

	/** ExitCode of the entire Kotlin compilation process */
	enum class ExitCode {
		OK, INTERNAL_ERROR, COMPILATION_ERROR, SCRIPT_EXECUTION_ERROR
	}

	/** Result of the compilation */
	inner class Result(
		/** The exit code of the compilation */
		val exitCode: ExitCode,
		/** Messages that were printed by the compilation */
		val messages: String
	) {
		/** class loader to load the compile classes */
		val classLoader = URLClassLoader(arrayOf(outputDirectory.toURI().toURL()),
			this::class.java.classLoader)

		/** The directory where only the final output class and resources files will be */
		val outputDirectory: File get() = classesDir

		/**
		 * 	Intermediate source and resource files generated by the annotation processor that
		 * 	will be compiled in the next steps.
		 */
		val sourcesGeneratedByAnnotationProcessor: List<File>
			get() = generatedSources

		/**
		 * Compiled class and resource files that are the final result of the compilation.
		 */
		val compiledClassAndResourceFiles: List<File> = outputDirectory.listFilesRecursively()

		/** Stub files generated by kapt */
		val generatedStubFiles: List<File>
			get() = kapt.stubsDir.listFilesRecursively()

		/**
		 * The class, resource and intermediate source files generated during the compilation.
		 * Does not include stub files and kapt incremental data.
		 */
		val generatedFiles: Collection<File>
				= sourcesGeneratedByAnnotationProcessor + compiledClassAndResourceFiles + generatedStubFiles
	}


	// setup common arguments for the two kotlinc calls
	internal fun commonK2JVMArgs() = commonArguments(K2JVMCompilerArguments()) { args ->
		args.destination = classesDir.absolutePath
		args.classpath = commonClasspaths().joinToString(separator = File.pathSeparator)

		if(jdkHome != null) {
			args.jdkHome = jdkHome!!.absolutePath
		}
		else {
			log("Using option -no-jdk. Kotlinc won't look for a JDK.")
			args.noJdk = true
		}

		args.includeRuntime = includeRuntime

		// the compiler should never look for stdlib or reflect in the
		// kotlinHome directory (which is null anyway). We will put them
		// in the classpath manually if they're needed
		args.noStdlib = true
		args.noReflect = true

		if(moduleName != null)
			args.moduleName = moduleName

		args.jvmTarget = jvmTarget
		args.javaParameters = javaParameters
		args.useIR = useIR

		if(javaModulePath != null)
			args.javaModulePath = javaModulePath!!.toString()

		args.additionalJavaModules = additionalJavaModules.map(File::getAbsolutePath).toTypedArray()
		args.noCallAssertions = noCallAssertions
		args.noParamAssertions = noParamAssertions
		args.noReceiverAssertions = noReceiverAssertions
		args.strictJavaNullabilityAssertions = strictJavaNullabilityAssertions
		args.noOptimize = noOptimize

		if(constructorCallNormalizationMode != null)
			args.constructorCallNormalizationMode = constructorCallNormalizationMode

		if(assertionsMode != null)
			args.assertionsMode = assertionsMode

		if(buildFile != null)
			args.buildFile = buildFile!!.toString()

		args.inheritMultifileParts = inheritMultifileParts
		args.useTypeTable = useTypeTable

		if(declarationsOutputPath != null)
			args.declarationsOutputPath = declarationsOutputPath!!.toString()

		args.singleModule = singleModule

		if(javacArguments.isNotEmpty())
			args.javacArguments = javacArguments.toTypedArray()

		if(supportCompatqualCheckerFrameworkAnnotations != null)
			args.supportCompatqualCheckerFrameworkAnnotations = supportCompatqualCheckerFrameworkAnnotations

		args.jvmDefault = jvmDefault
		args.strictMetadataVersionSemantics = strictMetadataVersionSemantics
		args.sanitizeParentheses = sanitizeParentheses

		if(friendPaths.isNotEmpty())
			args.friendPaths = friendPaths.map(File::getAbsolutePath).toTypedArray()

		if(scriptResolverEnvironment.isNotEmpty())
			args.scriptResolverEnvironment = scriptResolverEnvironment.map { (key, value) -> "$key=\"$value\"" }.toTypedArray()

		args.noExceptionOnExplicitEqualsForBoxedNull = noExceptionOnExplicitEqualsForBoxedNull
		args.skipRuntimeVersionCheck = skipRuntimeVersionCheck
        args.javaPackagePrefix = javaPackagePrefix
        args.suppressMissingBuiltinsError = suppressMissingBuiltinsError
	}

	/** Runs the compilation task */
	fun compile(): Result {
		// make sure all needed directories exist
		classesDir.mkdirs()

		pluginClasspaths.forEach { filepath ->
			if (!filepath.exists()) {
				error("Plugin $filepath not found")
				return makeResult(ExitCode.INTERNAL_ERROR)
			}
		}
		addCompilationStep(
			KotlinJvmCompilationStep() as CompilationStep<AbstractKotlinCompilation<K2JVMCompilerArguments>>
		)
		addCompilationStep(
			JavaCompilationStep() as CompilationStep<AbstractKotlinCompilation<K2JVMCompilerArguments>>
		)

		val (exitCode, _) = runCompilationSteps()
		return makeResult(exitCode)
	}

	private fun makeResult(exitCode: ExitCode): Result {
		val messages = model.internalMessageBuffer.readUtf8()

		if(exitCode != ExitCode.OK)
			searchSystemOutForKnownErrors(messages)

		return Result(exitCode, messages)
	}

	internal fun commonClasspaths() = mutableListOf<File>().apply {
		addAll(classpaths)
		addAll(listOfNotNull(kotlinStdLibJar,  kotlinStdLibCommonJar, kotlinStdLibJdkJar,
            kotlinReflectJar, kotlinScriptRuntimeJar
        ))

		if(inheritClassPath) {
			addAll(hostClasspaths)
			log("Inheriting classpaths:  " + hostClasspaths.joinToString(File.pathSeparator))
		}
	}.distinct()

	companion object {
		const val OPTION_KAPT_KOTLIN_GENERATED = "kapt.kotlin.generated"
    }
}
