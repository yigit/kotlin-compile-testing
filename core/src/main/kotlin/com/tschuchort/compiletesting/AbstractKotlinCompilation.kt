package com.tschuchort.compiletesting

import com.tschuchort.compiletesting.param.CompilationModel
import com.tschuchort.compiletesting.param.CompilationModelImpl
import com.tschuchort.compiletesting.step.CompilationStep
import com.tschuchort.compiletesting.step.StepRegistry
import io.github.classgraph.ClassGraph
import org.jetbrains.kotlin.cli.common.ExitCode
import org.jetbrains.kotlin.compiler.plugin.CommandLineProcessor
import org.jetbrains.kotlin.compiler.plugin.ComponentRegistrar
import java.io.File
import java.io.OutputStream

/**
 * Base compilation class for sharing common compiler arguments and
 * functionality. Should not be used outside of this library as it is an
 * implementation detail.
 */
abstract class AbstractKotlinCompilation<Model : CompilationModel>
        internal constructor(private val model: CompilationModelImpl) {

    fun model(): Model = model as Model

    val stepRegistry = StepRegistry<Model>()

    fun hasStep(id: String): Boolean = stepRegistry.hasStep(id)

    fun registerStep(step: CompilationStep<Model>,
                     shouldRunAfter : Set<String> = emptySet(),
                     shouldRunBefore: Set<String> = emptySet()
    ) {
        stepRegistry.registerStep(
            step = step,
            shouldRunAfter = shouldRunAfter,
            shouldRunBefore = shouldRunBefore
        )
    }

    internal fun runSteps() : StepRegistry.ExecutionResult {
        val compilationUtils = KotlinCompilationUtils(
            model.messageStream,
            model.environment
        )
        /* Work around for warning that sometimes happens:
        "Failed to initialize native filesystem for Windows
        java.lang.RuntimeException: Could not find installation home path.
        Please make sure bin/idea.properties is present in the installation directory"
        See: https://github.com/arturbosch/detekt/issues/630
        */
        return withSystemProperty("idea.use.native.fs.for.win", "false") {
            @Suppress("UNCHECKED_CAST")
            stepRegistry.execute(
                env = model.environment,
                compilationUtils = compilationUtils,
                params = model as Model // TODO this is not nice but OK for now
            )
        }
    }

    /** Working directory for the compilation */
    var workingDir: File by model::workingDir

    /**
     * Paths to directories or .jar files that contain classes
     * to be made available in the compilation (i.e. added to
     * the classpath)
     */
    // figure out why this is not working:
    // https://kotlinlang.org/docs/reference/delegated-properties.html#delegating-to-another-property
    // maybe because they are not delegates but just real properties?
    var classpaths: List<File> by model::classpaths

    /**
     * Paths to plugins to be made available in the compilation
     */
    var pluginClasspaths: List<File> by model::pluginClasspaths

    /**
     * Compiler plugins that should be added to the compilation
     */
    var compilerPlugins: List<ComponentRegistrar> by model::compilerPlugins

    /**
     * Commandline processors for compiler plugins that should be added to the compilation
     */
    var commandLineProcessors: List<CommandLineProcessor> by model::commandLineProcessors

    /** Source files to be compiled */
    var sources: List<SourceFile> by model::sources

    /** Print verbose logging info */
    var verbose: Boolean by model::verbose

    /**
     * Helpful information (if [verbose] = true) and the compiler
     * system output will be written to this stream
     */
    var messageOutputStream: OutputStream by model.messageStream::outputStream

    /** Inherit classpath from calling process */
    var inheritClassPath: Boolean by model::inheritClassPath

    /** Suppress all warnings */
    var suppressWarnings: Boolean by model::suppressWarnings

    /** All warnings should be treated as errors */
    var allWarningsAsErrors: Boolean by model::allWarningsAsErrors

    /** Report locations of files generated by the compiler */
    var reportOutputFiles: Boolean by model::reportOutputFiles

    /** Report on performance of the compilation */
    var reportPerformance: Boolean by model::reportPerformance


    /** Additional string arguments to the Kotlin compiler */
    var kotlincArguments: List<String> by model::kotlincArguments

    /** Options to be passed to compiler plugins: -P plugin:<pluginId>:<optionName>=<value>*/
    var pluginOptions: List<PluginOption> by model::pluginOptions

    /**
     * Path to the kotlin-stdlib-common.jar
     * If none is given, it will be searched for in the host
     * process' classpaths
     */
    var kotlinStdLibCommonJar: File? by model::kotlinStdLibCommonJar

    /** Searches compiler log for known errors that are hard to debug for the user */
    protected fun searchSystemOutForKnownErrors(compilerSystemOut: String) {
        if (compilerSystemOut.contains("No enum constant com.sun.tools.javac.main.Option.BOOT_CLASS_PATH")) {
            model.messageStream.warn(
                "${this::class.simpleName} has detected that the compiler output contains an error message that may be " +
                        "caused by including a tools.jar file together with a JDK of version 9 or later. " +
                        if (inheritClassPath)
                            "Make sure that no tools.jar (or unwanted JDK) is in the inherited classpath"
                        else ""
            )
        }

        if (compilerSystemOut.contains("Unable to find package java.")) {
            model.messageStream.warn(
                "${this::class.simpleName} has detected that the compiler output contains an error message " +
                        "that may be caused by a missing JDK. This can happen if jdkHome=null and inheritClassPath=false."
            )
        }
    }

    /** Tries to find a file matching the given [regex] in the host process' classpath */
    protected fun findInHostClasspath(hostClasspaths: List<File>, simpleName: String, regex: Regex): File? {
        val jarFile = hostClasspaths.firstOrNull { classpath ->
            classpath.name.matches(regex)
            //TODO("check that jar file actually contains the right classes")
        }

        if (jarFile == null)
            model.messageStream.log("Searched host classpaths for $simpleName and found no match")
        else
            model.messageStream.log("Searched host classpaths for $simpleName and found ${jarFile.path}")

        return jarFile
    }
}

internal fun kotlinDependencyRegex(prefix:String): Regex {
    return Regex("$prefix(-[0-9]+\\.[0-9]+(\\.[0-9]+)?)([-0-9a-zA-Z]+)?\\.jar")
}

/** Returns the files on the classloader's classpath and modulepath */
internal fun getHostClasspaths(): List<File> {
    val classGraph = ClassGraph()
        .enableSystemJarsAndModules()
        .removeTemporaryFilesAfterScan()

    val classpaths = classGraph.classpathFiles
    val modules = classGraph.modules.mapNotNull { it.locationFile }

    return (classpaths + modules).distinctBy(File::getAbsolutePath)
}

internal fun convertKotlinExitCode(code: ExitCode) = when(code) {
    ExitCode.OK -> KotlinCompilation.ExitCode.OK
    ExitCode.INTERNAL_ERROR -> KotlinCompilation.ExitCode.INTERNAL_ERROR
    ExitCode.COMPILATION_ERROR -> KotlinCompilation.ExitCode.COMPILATION_ERROR
    ExitCode.SCRIPT_EXECUTION_ERROR -> KotlinCompilation.ExitCode.SCRIPT_EXECUTION_ERROR
}
