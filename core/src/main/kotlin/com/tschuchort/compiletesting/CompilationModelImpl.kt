package com.tschuchort.compiletesting

import com.facebook.buck.jvm.java.javax.com.tschuchort.compiletesting.JsCompilationModel
import com.tschuchort.compiletesting.KotlinCompilation.Companion.OPTION_KAPT_KOTLIN_GENERATED
import io.github.classgraph.ClassGraph
import okio.Buffer
import org.jetbrains.kotlin.compiler.plugin.CommandLineProcessor
import org.jetbrains.kotlin.compiler.plugin.ComponentRegistrar
import org.jetbrains.kotlin.config.JVMAssertionsMode
import org.jetbrains.kotlin.config.JvmDefaultMode
import org.jetbrains.kotlin.config.JvmTarget
import java.io.File
import java.io.OutputStream
import java.io.PrintStream
import java.nio.file.Files
import java.nio.file.Path
import javax.annotation.processing.Processor
import kotlin.reflect.KClass

sealed class CompilationModelImpl : CompilationModel {
    override val extensionData: MutableMap<KClass<*>, Any> = mutableMapOf()

    override fun <T:Any> getExtensionData(key: KClass<T>) : T? {
        return extensionData.get(key) as? T
    }

    override fun <T:Any> getOrPutExtensionData(key: KClass<T>, create: () -> T) : T {
        getExtensionData(key)?.let {
            return it
        }
        return create().also {
            putExtensionData(key, it)
        }
    }

    fun <T:Any> putExtensionData(key: KClass<T>, value: T) {
        extensionData[key] = value
    }

    /** Working directory for the compilation */
    override var workingDir: File by default {
        val path = Files.createTempDirectory("Kotlin-Compilation")
        log("Created temporary working directory at ${path.toAbsolutePath()}")
        return@default path.toFile()
    }

    /**
     * Paths to directories or .jar files that contain classes
     * to be made available in the compilation (i.e. added to
     * the classpath)
     */
    override var classpaths: List<File> = emptyList()

    /**
     * Paths to plugins to be made available in the compilation
     */
    override var pluginClasspaths: List<File> = emptyList()

    /**
     * Compiler plugins that should be added to the compilation
     */
    override var compilerPlugins: List<ComponentRegistrar> = emptyList()

    /**
     * Commandline processors for compiler plugins that should be added to the compilation
     */
    override var commandLineProcessors: List<CommandLineProcessor> = emptyList()

    /** Source files to be compiled */
    override var sources: List<SourceFile> = emptyList()

    /** Print verbose logging info */
    override var verbose: Boolean = true

    /**
     * Helpful information (if [verbose] = true) and the compiler
     * system output will be written to this stream
     */
    override var messageOutputStream: OutputStream = System.out

    /** Inherit classpath from calling process */
    override var inheritClassPath: Boolean = false

    /** Suppress all warnings */
    override var suppressWarnings: Boolean = false

    /** All warnings should be treated as errors */
    override var allWarningsAsErrors: Boolean = false

    /** Report locations of files generated by the compiler */
    override var reportOutputFiles: Boolean by default { verbose }

    /** Report on performance of the compilation */
    override var reportPerformance: Boolean = false


    /** Additional string arguments to the Kotlin compiler */
    override var kotlincArguments: List<String> = emptyList()

    /** Options to be passed to compiler plugins: -P plugin:<pluginId>:<optionName>=<value>*/
    override var pluginOptions: List<PluginOption> = emptyList()

    /**
     * Path to the kotlin-stdlib-common.jar
     * If none is given, it will be searched for in the host
     * process' classpaths
     */
    override var kotlinStdLibCommonJar: File? by default {
        findInHostClasspath(hostClasspaths, "kotlin-stdlib-common.jar",
            kotlinDependencyRegex("kotlin-stdlib-common")
        )
    }

    override val hostClasspaths by lazy { resolveHostClasspaths() }

    // Directory for input source files
    override val sourcesDir get() = workingDir.resolve("sources")

    /* This internal buffer and stream is used so it can be easily converted to a string
    that is put into the [Result] object, in addition to printing immediately to the user's
    stream. */
    internal val internalMessageBuffer = Buffer()
    internal val internalMessageStream = PrintStream(
        TeeOutputStream(
            object : OutputStream() {
                override fun write(b: Int) = messageOutputStream.write(b)
                override fun write(b: ByteArray) = messageOutputStream.write(b)
                override fun write(b: ByteArray, off: Int, len: Int) = messageOutputStream.write(b, off, len)
                override fun flush() = messageOutputStream.flush()
                override fun close() = messageOutputStream.close()
            },
            internalMessageBuffer.outputStream()
        )
    )
    override fun log(s: String) {
        if (verbose)
            internalMessageStream.println("logging: $s")
    }

    override fun warn(s: String) {
        internalMessageStream.println("warning: $s")
    }

    override fun error(s: String) {
        internalMessageStream.println("error: $s")
    }

    /** Tries to find a file matching the given [regex] in the host process' classpath */
    override fun findInHostClasspath(hostClasspaths: List<File>, simpleName: String, regex: Regex): File? {
        val jarFile = hostClasspaths.firstOrNull { classpath ->
            classpath.name.matches(regex)
            //TODO("check that jar file actually contains the right classes")
        }

        if (jarFile == null)
            log("Searched host classpaths for $simpleName and found no match")
        else
            log("Searched host classpaths for $simpleName and found ${jarFile.path}")

        return jarFile
    }

    /** Returns the files on the classloader's classpath and modulepath */
    override fun resolveHostClasspaths(): List<File> {
        val classGraph = ClassGraph()
            .enableSystemJarsAndModules()
            .removeTemporaryFilesAfterScan()

        val classpaths = classGraph.classpathFiles
        val modules = classGraph.modules.mapNotNull { it.locationFile }

        return (classpaths + modules).distinctBy(File::getAbsolutePath)
    }

    internal class JvmCompilationModelImpl : CompilationModelImpl(), JvmCompilationModel {
        /** Include Kotlin runtime in to resulting .jar */
        override var includeRuntime: Boolean = false

        /** Name of the generated .kotlin_module file */
        override var moduleName: String? = null

        /** Target version of the generated JVM bytecode */
        override var jvmTarget: String = JvmTarget.DEFAULT.description

        /** Generate metadata for Java 1.8 reflection on method parameters */
        override var javaParameters: Boolean = false

        /** Use the IR backend */
        override var useIR: Boolean = false

        /** Paths where to find Java 9+ modules */
        override var javaModulePath: Path? = null

        /**
         * Root modules to resolve in addition to the initial modules,
         * or all modules on the module path if <module> is ALL-MODULE-PATH
         */
        override var additionalJavaModules: MutableList<File> = mutableListOf()

        /** Don't generate not-null assertions for arguments of platform types */
        override var noCallAssertions: Boolean = false

        /** Don't generate not-null assertion for extension receiver arguments of platform types */
        override var noReceiverAssertions: Boolean = false

        /** Don't generate not-null assertions on parameters of methods accessible from Java */
        override var noParamAssertions: Boolean = false

        /** Generate nullability assertions for non-null Java expressions */
        override var strictJavaNullabilityAssertions: Boolean = false

        /** Disable optimizations */
        override var noOptimize: Boolean = false

        /**
         * Normalize constructor calls (disable: don't normalize; enable: normalize),
         * default is 'disable' in language version 1.2 and below, 'enable' since language version 1.3
         *
         * {disable|enable}
         */
        override var constructorCallNormalizationMode: String? = null

        /** Assert calls behaviour {always-enable|always-disable|jvm|legacy} */
        override var assertionsMode: String? = JVMAssertionsMode.DEFAULT.description

        /** Path to the .xml build file to compile */
        override var buildFile: File? = null

        /** Compile multifile classes as a hierarchy of parts and facade */
        override var inheritMultifileParts: Boolean = false

        /** Use type table in metadata serialization */
        override var useTypeTable: Boolean = false

        /** Allow Kotlin runtime libraries of incompatible versions in the classpath */
        override var skipRuntimeVersionCheck: Boolean = false

        /** Path to JSON file to dump Java to Kotlin declaration mappings */
        override var declarationsOutputPath: File? = null

        /** Combine modules for source files and binary dependencies into a single module */
        override var singleModule: Boolean = false

        /** Suppress the \"cannot access built-in declaration\" error (useful with -no-stdlib) */
        override var suppressMissingBuiltinsError: Boolean = false

        /** Script resolver environment in key-value pairs (the value could be quoted and escaped) */
        override var scriptResolverEnvironment: MutableMap<String, String> = mutableMapOf()

        /** Java compiler arguments */
        override var javacArguments: MutableList<String> = mutableListOf()

        /** Package prefix for Java files */
        override var javaPackagePrefix: String? = null

        /**
         * Specify behavior for Checker Framework compatqual annotations (NullableDecl/NonNullDecl).
         * Default value is 'enable'
         */
        override var supportCompatqualCheckerFrameworkAnnotations: String? = null

        /** Do not throw NPE on explicit 'equals' call for null receiver of platform boxed primitive type */
        override var noExceptionOnExplicitEqualsForBoxedNull: Boolean = false

        /** Allow to use '@JvmDefault' annotation for JVM default method support.
         * {disable|enable|compatibility}
         * */
        override var jvmDefault: String = JvmDefaultMode.DEFAULT.description

        /** Generate metadata with strict version semantics (see kdoc on Metadata.extraInt) */
        override var strictMetadataVersionSemantics: Boolean = false

        /**
         * Transform '(' and ')' in method names to some other character sequence.
         * This mode can BREAK BINARY COMPATIBILITY and is only supposed to be used as a workaround
         * of an issue in the ASM bytecode framework. See KT-29475 for more details
         */
        override var sanitizeParentheses: Boolean = false

        /** Paths to output directories for friend modules (whose internals should be visible) */
        override var friendPaths: List<File> = emptyList()

        /**
         * Path to the JDK to be used
         *
         * If null, no JDK will be used with kotlinc (option -no-jdk)
         * and the system java compiler will be used with empty bootclasspath
         * (on JDK8) or --system none (on JDK9+). This can be useful if all
         * the JDK classes you need are already on the (inherited) classpath.
         * */
        override var jdkHome: File? by default { getJdkHome() }

        /**
         * Path to the kotlin-stdlib.jar
         * If none is given, it will be searched for in the host
         * process' classpaths
         */
        override var kotlinStdLibJar: File? by default {
            findInHostClasspath(hostClasspaths, "kotlin-stdlib.jar",
                kotlinDependencyRegex("(kotlin-stdlib|kotlin-runtime)"))
        }

        /**
         * Path to the kotlin-stdlib-jdk*.jar
         * If none is given, it will be searched for in the host
         * process' classpaths
         */
        override var kotlinStdLibJdkJar: File? by default {
            findInHostClasspath(hostClasspaths, "kotlin-stdlib-jdk*.jar",
                kotlinDependencyRegex("kotlin-stdlib-jdk[0-9]+"))
        }

        /**
         * Path to the kotlin-reflect.jar
         * If none is given, it will be searched for in the host
         * process' classpaths
         */
        override var kotlinReflectJar: File? by default {
            findInHostClasspath(hostClasspaths, "kotlin-reflect.jar",
                kotlinDependencyRegex("kotlin-reflect"))
        }

        /**
         * Path to the kotlin-script-runtime.jar
         * If none is given, it will be searched for in the host
         * process' classpaths
         */
        override var kotlinScriptRuntimeJar: File? by default {
            findInHostClasspath(hostClasspaths, "kotlin-script-runtime.jar",
                kotlinDependencyRegex("kotlin-script-runtime"))
        }

        /**
         * Path to the tools.jar file needed for kapt when using a JDK 8.
         *
         * Note: Using a tools.jar file with a JDK 9 or later leads to an
         * internal compiler error!
         */
        override var toolsJar: File? by default {
            if (!isJdk9OrLater())
                jdkHome?.let { findToolsJarFromJdk(it) }
                    ?: findInHostClasspath(hostClasspaths, "tools.jar", Regex("tools.jar"))
            else
                null
        }

        // *.class files, Jars and resources (non-temporary) that are created by the
        // compilation will land here
        override val classesDir get() = workingDir.resolve("classes")
    }

    class JsCompilationModelImpl : CompilationModelImpl(), JsCompilationModel {
        override var outputFileName: String = "test.js"

        /**
         * Generate unpacked KLIB into parent directory of output JS file. In combination with -meta-info
         * generates both IR and pre-IR versions of library.
         */
        override var irProduceKlibDir: Boolean = false

        /** Generate packed klib into file specified by -output. Disables pre-IR backend */
        override var irProduceKlibFile: Boolean = false

        /** Generates JS file using IR backend. Also disables pre-IR backend */
        override var irProduceJs: Boolean = false

        /** Perform experimental dead code elimination */
        override var irDce: Boolean = false

        /** Perform a more experimental faster dead code elimination */
        override var irDceDriven: Boolean = false

        /** Print declarations' reachability info to stdout during performing DCE */
        override var irDcePrintReachabilityInfo: Boolean = false

        /** Disables pre-IR backend */
        override var irOnly: Boolean = false

        /** Specify a compilation module name for IR backend */
        override var irModuleName: String? = null

        /**
         * Path to the kotlin-stdlib-js.jar
         * If none is given, it will be searched for in the host
         * process' classpaths
         */
        override var kotlinStdLibJsJar: File? by default {
            findInHostClasspath(hostClasspaths, "kotlin-stdlib-js.jar",
                kotlinDependencyRegex("kotlin-stdlib-js"))
        }

        // *.class files, Jars and resources (non-temporary) that are created by the
        // compilation will land here
        override val outputDir get() = workingDir.resolve("output")
    }
}
